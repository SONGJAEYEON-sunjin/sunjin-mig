# [[ 데이터 이관 메뉴얼 ]]

## 작업 순서 
 > 1. ASIS 데이터 덤프 
 > 2. SEAL IMAGE 다운로드 
 > 3. 이관프로그램 실행 환경 구성 
 > 4. 이관프로그램 실행 및 데이터 검증 
 > 5. 이관 쿼리 실행 및 데이터 검증 
 > 6. 이관결과서 작성

---
 
## [ 1. ASIS 데이터 덤프 ]

### 1) DBeaver Task 를 이용한 데이터 덤프
* DP_APP_DOC 데이터 덤프 
  ```text
  ㅇ dbeaver task 생성  ( 사용쿼리 : /docs/01.dump/dump(2025.06).sql)
   - 상단메뉴>[윈도우]>[Database Task]> 우클릭>Create New Task 
   - Name 입력 후 Data Export  
   - [Add Query] 선택 후 select를 실행할 스키마 선택 후 쿼리 입력
        - Extraction settings 
            Maximum threads : 5
            Extract type : Multiple queries
            Segment size : 1500 
            [v] Open new Connection
            [v] Select row count
            Fetch size : 1500   
        - Data load settings 
            [v] Transfer auto-generated columns
            Replace method : INSERT IGNORE 
            [v] Open new Connection
            [v] Use transactions
            Do Commit after row insert : 600
            [v] Use multi-row value insert : 200 
            
  ㅇ 범위나눠서 task 여러개 생성 
  ㅇ 순차 실행
  ```

* DP_APP_DOC 외 데이터 덤프 
  ```text
    ㅇ dbeaver task 생성
     - [Add Table] 선택하여 dump 대상 테이블 하나씩 추가 
     -  Extraction settings 
            Maximum threads : 5
            Extract type : Multiple queries
            Segment size : 1500 
            [v] Open new Connection
            [v] Select row count
            Fetch size : 1500   
        - Data load settings 
            [v] Transfer auto-generated columns
            Replace method : INSERT IGNORE 
            [v] Open new Connection
            [v] Use transactions
            Do Commit after row insert : 600
            [v] Use multi-row value insert : 200  
    ㅇ 실행
  ```
*  스크립트 실행  
  ```text
    ㅇ 제약조건 생성  (/docs/dump/dump_constraint.sql)
    ㅇ index 생성 (/docs/dump/dump_index.sql)
    ㅇ 이관용 테이블 클렌징 및 데이터 넣기 (/docs/dump/doc_detail.sql)
  ```
---

## [ 2. SEAL IMAGE 다운로드 ]
* 이미지 경로 추출 스크립트 실행 (/docs/02.sealImage/이미지경로추출.sql)
* 추출한 csv파일을 경로를 수정하여 추출 소스코드 실행 (/batch/file/FileDnldRunner.java Application Run) 
---

## [ 3. 이관 프로그램 실행환경 구성 ]
### 1) 실행환경 구성
* jdk 17 설치 및 소스코드 세팅 (jdk 17이 있다면 생략 가능)
  ```text
  ㅇ/docs/03.설치/jdk-17.0.1.zip 압축해제 후 설치
   ```
* 필요 라이브러리 세팅(그래들 빌드)
  ```text
  ㅇ 에디터로 프로젝트 오픈 후 빌드 (Gradle build) -- 아 그냥 이거 그대로갖고가서 실행하실수있도록,, 해야할까...  
  ```
* 필요 파라미터값 세팅
  ```text
  ㅇ  /resources/application.yml -- 공통 작업 설정 
  ㅇ  /resources/application-dev.yml -- 개발환경 작업시 필요한 설정
  ㅇ  /resources/application-prod.yml -- 운영환경 작업시 필요한 설정 
  ```
* 실행 
  ```text
  ㅇ /java/com/kcube/trns/sunjin/SunjinApplication.java 에서 application run   
  ```

### 2) 이관 프로그램 구조 및 순서 
* DOC_ITEM 서브 테이블 이관은 스크립트로 대체함 (속도이슈)
```text

    masterJob
      └── cacheInitJobStep() -- 이관에 필요한 캐시 적재 (사용자,부서,보안,문서세부정보)
      └── parallelMigrationJobStep() -- 데이터 이관 진행 
            ↓
    parallelMigrationJob
      ├── docPartitionedStep           -- AP_ITEM 으로 이관 진행 (구간별 병렬 진행)
      ├── updateOrgIdByQueryStep       -- AP_ITEM.ORGID 보정쿼리 실행   
      ├── apItemCacheStep              -- AP_ITEM.ITEMID, AP_ITEM.TRNS_KEY 캐시 적재 
      └── parallelDocFlowStep          -- AP_ITEM_XXX 테이블 이관 (각 테이블 별로 병렬로 진행)
            └── parallelDocFlow [Flow]
                  ├── opnFlow
                  │     ├── docOpnStep                     -- AP_ITEM_OPN 으로 이관 진행
                  │     ├── updateOpnGidStep               -- AP_ITEM_OPN.GID 보정쿼리 실행    
                  │     └── updateOpnSortStep              -- AP_ITEM_OPN.SORT 보정쿼리 실행    
                  │
                  ├── scrtFlow
                  │     └── docScrtPartitionStep           -- AP_ITEM_SCRT 으로 이관 진행(구간별 병렬 진행) 
                  │
                  ├── srchFlow
                  │     └── docSrchPartitionStep           -- AP_ITEM_SRCH 으로 이관 진행(구간별 병렬 진행)
                  │
                  ├── lineFlow
                  │     └── docLinePartitionStep           -- AP_ITEM_LINE 으로 이관 진행(구간별 병렬 진행)
                  │
                  ├── fileFlow
                  │     └── docFileStep                     -- AP_ITEM_FILE 으로 이관 진행 // 해당 STEP은 스크립트로 대체함(속도이슈)
                  │
                  ├── shareFlow
                  │     ├── docCirDocStep                  -- AP_ITEM_SHARE 으로 이관 진행
                  │     ├── docForwardStep                 -- AP_ITEM_SHARE 으로 이관 진행
                  │     └── docCarbonPartitionStep         -- AP_ITEM_SHARE 으로 이관 진행(구간별 병렬 진행)
                  │
                  ├── toDocFlowAndRfrn
                  │     ├── toDocItemStep                  -- DOC_ITEM 으로 이관 진행
                  │     ├── toDocUpdateOrgIdByQueryStep    -- DOC_ITEM.ORGID 보정쿼리 실행   
                  │     ├── docItemCacheStep               -- DOC_ITEM.ITEMID, DOC_ITEM.TRNS_KEY 캐시 적재 
                  │     └── docRfrnStep                    -- AP_ITEM_RFRN 으로 이관 진행 // 해당 STEP은 스크립트로 대체함(속도이슈)
                  │
                  └── rcvrFlow
                        └── docRcrvStep                    -- AP_ITEM_RCVR 으로 이관 진행
```
--- 

## [ 4. 이관프로그램 실행 및 데이터 검증  ]
 
### ㅇ 작업 및 모니터링 방법 

1) 작업탬플릿 준비(/docs/04.이관/01.작업탬플릿(AP).md)
2) 이관프로그램 실행 (Application Run)
3) 이관 프로그램 STEP별 확인 
```text
    select 
    STEP_EXECUTION_ID, -- STEP ID
    JOB_EXECUTION_ID , -- JOB ID
    step_name, -- STEP 이름 
    END_TIME, -- 종료시간 (종료된 STEP에 대해서만 값이 존재)
    read_count, 
    write_count,
    exit_code,-- 종료코드 ('EXECUTING'/'COMPLETED'/'FAILED')
    EXIT_MESSAGE -- 종료메시지(실패시 에러메시지가 기록됨)
    from batch_step_execution 
    -- and exit_code = 'EXECUTING' -- 실행중인 STEP
    -- and exit_code = 'COMPLETED' -- 완료된 STEP
    -- and exit_code = 'FAILED' -- 실패한 STEP
    order by step_execution_id desc;
    
    ** 실행할때마다 로그가 쌓임으로 가장최신 JOB_EXECUTION_ID를 가진 STEP들에 대해서 확인하면 됨.
```
### ㅇ 실패 STEP 재실행 방법

#### 1) 실패 STEP 및 범위 파악
```text
    1) select 
    step_name, -- STEP 이름 
    job_execution_id, -- JOB ID
    read_count,  -- read 건수 
    write_count, -- write 건수(commit이 완료됨)
    exit_code,-- 종료코드 ('EXECUTING'/'COMPLETED'/'FAILED')
    EXIT_MESSAGE -- 종료메시지(실패시 에러메시지가 기록됨)
    from batch_step_execution 
    order by step_execution_id desc;
    -- EXIT_CODE = 'FAILED'인 STEP의 EXIT_MESSAGE를 확인 후 에러 조치
    
    2) select SHORT_CONTEXT from batch_step_execution_context where step_execution_id = 1;
    -- SHORT_CONTEXT 값을 직렬화(BatchContextDeserializer.java 실행)하여 minid, maxid 값을 찾음
    
    3) select count(*) from dp_app_doc where documentid between ${:minId} and ${:maxId};  
    -- SHORT_CONTEXT 값에서 찾은 minid, maxid 값을 통해 실패한 partition 범위 count 확인  
```
#### 2) 특정 STEP 범위지정 재실행
* STEP NAME에 Partition 이 붙어있는 경우 (예 : docLinePartitionStep)
```text
    (1) 재실행 범위 결정 
     -- 실패한 STEP 또는 범위 전체 삭제 후 재실
    
    (2) XXXReader.java 에서 주석해제 후 min, max 값 설정 
    
    (3) 재실행할 STEP 제외 주석처리 후 실행 
```

* STEP NAME에 Partition 이 붙어있지 않은 경우 (예 : docRcvrStep)
```text
    (1) 재실행 범위 확인
     - 해당 테이블 확인 후 max값 이후부터 이관 진행 가능 
     - 전체 삭제 후 다시 진행해도 무관 
     
    (2) 재실행 범위 설정
     - MigrationJobConfig.parallelMigrationJob 에서 실패복구 STEP의 reader.java 확인
     - 해당 reader 에서 재실행범위 (where 조건) 설정 
       
    (3) 재실행할 STEP 실행
     ㅇ 실패복구 STEP 중 재실행할 STEP만 주석해제하여 실행 
     ㅇ 주의! 위 STEP은 모두 주석처리해야함
```

--- 

## [ 5. 이관 쿼리 실행 및 데이터 검증  ]
### ㅇ 작업방법 

1) 작업탬플릿 준비(/docs/04.이관/01.작업탬플릿(DOC).md)
2) 쿼리 순차 실행

## [ 6. 이관결과서 작성  ]

### ㅇ 작성방법 
* 쿼리 실행 후 결과 값 입력 
* 이관 결과서 양식 (/docs/05.결과서/결과서양식.xlsx) 
* ASIS 추출건수 확인 쿼리 (/docs/05.결과서/ASIS_ROW_CNT.sql)
* TOBE(AP) 추출건수 확인 쿼리 (/docs/05.결과서/TOBE_ROW_CNT_AP.sql)
* TOBE(DOC) 추출건수 확인 쿼리 (/docs/05.결과서/TOBE_ROW_CNT_DOC.sql) 



